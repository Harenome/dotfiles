#!/bin/bash
# Little dotfiles manager

# Program: dotm
# Author: Harenome RANAIVOARIVONY RAZANAJATO
# Version: 0.4
# Date: May 8th 2013
# License: WTFPL v2
#
# This program is free software. It comes WITHOUT ANY WARRANTY, to
# the extent permitted by applicable law. You can redistribute it
# and/or modify it under the terms of the Do What The Fuck You Want
# To Public License, Version 2, as published by Sam Hocevar. See
# http://sam.zoy.org/wtfpl/COPYING for more details.

#------------------------------------------------------------------------------
# Global variables
#------------------------------------------------------------------------------

## User variables
# Replace $HOME with another location for tests
BACKUPDIR=backups
CONFIGDIR=$HOME
CONFIGFILE="dotm.rc"

## Variables for version and help printing
DATE="May 8th 2013"
VERSION="0.3.1"
LICENCEDISCLAIMER="This program is free software. It comes WITHOUT ANY WARRANTY, to
the extent permitted by applicable law. You can redistribute it
and/or modify it under the terms of the Do What The Fuck You Want
To Public License, Version 2, as published by Sam Hocevar. See
http://www.wtfpl.net for more details."

AUTHORS="Harenome Ranaivoarivony Razanajato"

VERSIONSTRING="dotm, version $VERSION ($DATE)

$LICENCEDISCLAIMER

Written by $AUTHORS"

HELPSTRING="Usage: $0 [OPTIONS]... [FILES]...

Options:
    --no-backup
        disable backups
    --force-overwrite
        force overwriting of links, files and dir
    --overwrite-link
        overwrite links
    --overwrite-file
        overwrite files
    --overwrite-dir
        overwrite directories
    --verbose
        enable verbose mode
    --list
        list available sections
    --help
        print this help
    --version
        print the version
"

## Vital variables for the script
# Dirty (and hopefully, temporary) way to get the full path
DIRNAME="$(pwd)$([[ $(dirname $0) = "." ]] || echo "/$(dirname $0)")"

DOBACKUPS=true
FORCEOVERWRITE=false
OVERWRITELINK=false
OVERWRITEFILE=false
OVERWRITEDIR=false
VERBOSE=false
WRONGARGUMENT=false
UNKNOWNSECTION=false
FILELIST=( )

#------------------------------------------------------------------------------
# Functions
#------------------------------------------------------------------------------

function version
{
    echo -e "$VERSIONSTRING"
}

function printHelp
{
    # TODO: complete the help

    echo -e "$HELPSTRING"
}

function backup
{
    if $VERBOSE; then echo "Backuping $DESTINATION."; fi
    cp -r "$1" $BACKUPDIR/
}

# Not tested yet
function restore
{
    cp -rf "backups/$1" $CONFIGDIR/
}

function createLink
{
    # TODO: manage overwriting of regular files and directories

    # ln has a backup feature, however it is limited
    # (the backup is done in the same directory)
    local TARGET="$DIRNAME/$2"
    local DESTINATION="$CONFIGDIR/$1"

    if [[ -e "$DESTINATION" ]]; then
        if [[ -h "$DESTINATION" ]]; then
            if $VERBOSE; then echo "$DESTINATION is a link to $(readlink $DESTINATION)." 1>&2; fi
            if $OVERWRITELINK || $FORCEOVERWRITE; then
                if $VERBOSE; then echo "Overwriting the link (New target: $TARGET)."; fi
                ln -sf "$TARGET" "$DESTINATION"
            elif $VERBOSE; then
                echo "Ignoring. ($TARGET to $DESTINATION)" 1>&2
            fi
        elif [[ -f "$DESTINATION" ]]; then
            if $VERBOSE; then echo "There already exists a file at $DESTINATION." 1>&2; fi
            if $OVERWRITEFILE || $FORCEOVERWRITE; then
                if $DOBACKUPS; then backup "$DESTINATION"; fi
                if $VERBOSE; then echo "Creating the symbolic link. $DESTINATION will lead to $TARGET."; fi
                ln -sf "$TARGET" "$DESTINATION"
            elif $VERBOSE; then
                echo "Ignoring. ($TARGET to $DESTINATION)" 1>&2
            fi
        elif [[ -d "$DESTINATION" ]]; then
            if $VERBOSE; then echo "$DESTINATION is a directory." 1>&2; fi
            if $OVERWRITEDIR || $FORCEOVERWRITE; then
                if $DOBACKUPS; then backup "$DESTINATION"; fi
                if $VERBOSE; then echo "Creating the symbolic link. $DESTINATION will lead to $TARGET."; fi
                rm -r "$DESTINATION"
                ln -sf "$TARGET" "$DESTINATION"
            elif $VERBOSE; then
                echo "Ignoring. ($TARGET to $DESTINATION)" 1>&2
            fi
        fi
    else
        if $VERBOSE; then echo "Creating the symbolic link. $DESTINATION will lead to $TARGET."; fi
        ln -s "$TARGET" "$DESTINATION"
    fi

}

function checkConfigFile
{
    local HASERROR=false

    if [[ -f "$CONFIGFILE" ]]; then
        for FILE in $(grep -Env "#|:|^$" $CONFIGFILE | cut -d " " -f 2); do
            [[ ! -e "$FILE" ]] &&
            echo "Error: The file $FILE does not exist. Please check your $CONFIGFILE file." 1>&2 &&
            HASERROR=true
        done
    else
        echo "Error: The config file \"$CONFIGFILE\" does not exist." 1>&2
        HASERROR=true
    fi

    if $HASERROR; then exit 78; fi
}

function isInConfigFile
{
    if ! grep "^$(echo $1):$" $CONFIGFILE > /dev/null; then
        echo "Error: Don't know how to handle the config files for $1. Please check your $CONFIGFILE file." 1>&2
        UNKNOWNSECTION=true
    else
        FILELIST=( ${FILELIST[@]} $1 )
    fi
}

function singleConfig
{
    # Previous way to do so was to get the line number and read the file starting here.
    # TODO: Use awk's match.
    BEGINNING=$(grep -n "^$(echo $1):$" $CONFIGFILE | cut -d ':' -f 1)
    awk '{ if (NR > '$BEGINNING') if (length($0) > 0) { print } else { exit } }' $CONFIGFILE | while read DEST TARG; do
        createLink "$DEST" "$TARG"
    done
}

function allConfig
{
    awk '{ if (! match($0,":|^#|^$")) { print } }' $CONFIGFILE | while read DEST TARG; do
        createLink "$DEST" "$TARG"
    done
}

function listSections
{
    grep "^.*:$" $CONFIGFILE | tr -d ':'
}

#------------------------------------------------------------------------------
# Main
#------------------------------------------------------------------------------

checkConfigFile
mkdir -p $BACKUPDIR

if [[ $# -eq 0 ]]; then
    allConfig
else
    # getopt and getopts are a bit painful
    for ARG in $*; do
        if [[ ${ARG:0:1} = "-" ]] && [[ ${ARG:0:2} != "--" ]]; then
            case $ARG in
                "-v" ) VERBOSE=true;;
                "-f" ) FORCEOVERWRITE=true;;
                "-l" ) listSections; exit 0;;
                "-V" ) version; exit 0;;
                "-h" ) printHelp; exit 0;;
                * ) echo "Wrong option: $ARG" 1>&2; WRONGARGUMENT=true;;
            esac
        elif [[ ${ARG:0:2} = "--" ]]; then
            case $ARG in
                "--verbose" ) VERBOSE=true;;
                "--no-backup" ) DOBACKUPS=false;;
                "--overwrite-link" ) OVERWRITELINK=true;;
                "--overwrite-file" ) OVERWRITEFILE=true;;
                "--overwrite-dir" ) OVERWRITEDIR=true;;
                "--force-overwrite" ) FORCEOVERWRITE=true;;
                "--list" ) listSections; exit 0;;
                "--version" ) version; exit 0;;
                "--help" ) printHelp; exit 0;;
                * ) echo "Wrong option: $ARG" 1>&2; WRONGARGUMENT=true;;
            esac
        else
            isInConfigFile $ARG
        fi
    done

    if $WRONGARGUMENT; then exit 64; fi
    if $UNKNOWNSECTION; then exit 78; fi

    if [[ ${#FILELIST} -eq 0 ]]; then
        allConfig
    else
        for FILE in ${FILELIST[@]}; do
            singleConfig $FILE
        done
    fi
fi

exit 0
